package com.example.learnstupidandroid.docs.language

import com.example.learnstupidandroid.common.Doc

object Classes : Doc() {

    /**
     * - Data class vs Class vs Open class
     * - Nested and Inner Class
     * - Enum, Sealed class, sealed interface
     *
     * - Functional Interfaces
     * - Type aliases
     *
     * - val vs var vs const, lateinit
     * - Destructuring declarations
     **/
    override fun init() {
        docs()
    }

    override fun docs() {
        classesInheritance()
        dataSimpleClasses()
        nestedClasses()
        enumsSealed()
        functionalInterface()
        typeAliases()
        properties()
        destructingDeclaration()
    }

    /**
     * All classes are a subtype of **Any** superclass
     *
     * Any has 3 methods: **equals(), hashCode(), toString()**,
     * these methods are defined for all Kotlin classes
     *
     *
     * By default, all classes are final, to allow inheritance, use **open**
     *
     * Member of overridden class is open by default, to  make it final use: **final override fun**
     *```
     * open class Rectangle : Shape() {
     *     override fun draw() {}
     *     final override fun resize() {}
     * }
     * ```
     **/
    private fun classesInheritance() {
        open class Shape {
            open fun draw() {}
            open fun resize() {}
            fun fill() {}
        }

        open class Rectangle : Shape() {
            override fun draw() {}
            final override fun resize() {}
        }

        class Square : Rectangle() {
            override fun draw() {}
        }
    }

    /**
     * **data class**
     * - primary constructor at least 1 param
     * - primary constructor params val or var
     * - cannot be abstract, open, sealed, or inner
     *
     * compiler automatically generated following functions:
     * - equals(), hashcode()
     * - toString()
     * - componentN() corresponding to the properties in their order of declaration (used in destructing declarations [destructingDeclaration])
     * - copy()
     *
     * compiler only generates above functions for constructor params.
     * if they are in class body, they are not included in autogenerated functions.
     *
     * standard data classes: Pair, Triple
     * ```
     * ```
     * **data class vs class**
     * ```
     * class Person(var name: String)
     * data class DataPerson(var name: String)
     *
     * Person
     * fields: name
     * methods: getName setName
     *
     * DataPerson
     * fields: name
     * methods: getName setName equals hashCode toString copy copy$default component1
     * ```
     * for simple class, if equals() and hashcode() is NOT provided,
     * it will compare values by reference in memory (compare if it is the same object)
     *
     * this behaviour is derived from Any super class
     */
    private fun dataSimpleClasses() {
        open class Shape {
            open fun draw() {}
            open fun resize() {}
            fun fill() {}
        }

        open class Rectangle : Shape() {
            override fun draw() {}
            final override fun resize() {}
        }

        class Square : Rectangle() {
            override fun draw() {}
        }
    }

    /**
     * **nested class** - class inside another class
     * - static class
     * - we can use nested class properties without creating object of outer class
     * - in nested class we cannot access the properties of outer class
     * ```
     * class Outer {
     *    class Nested {}
     * }
     * val nested = Outer.Nested()
     * ```
     * **inner class**
     * - non-static nested class
     * - carries a reference to an object of an outer class
     * - can access members of outer class
     * - cannot create instance of inner class without creating instance of outer class
     * ```
     * class Outer {
     *     inner class Inner {}
     * }
     * val outer = Outer()
     * val inner = outer.Inner()
     * ```
     **/
    private fun nestedClasses() {
        val nested = Outer.Nested()
        val inner = Outer().Inner()
    }

    class Outer {
        class Nested {}
        inner class Inner {}
    }

    /**
     * **enum vs sealed class vs sealed interface**
     *
     * sealed classes are used for defining a restricted hierarchy of related classes, often with properties and methods,
     * while enum classes are used to define a fixed set of constant values
     *
     * **enum class**
     * - all enums values are constants (objects)
     * - each value in an enum class is a singleton object
     * - enum class can implement interface (but not extend the class)
     * - all enum classes implement Comparable by default
     *
     * **sealed class**
     * - the parent class is an abstract class
     * - all subclasses are known on compile time
     * - no other subclasses may appear outside the module and package where sealed class is (because default constructor is protected, can also be private)
     * ```
     * sealed class HttpError(val code: Int) {
     *     object ErrorNotFound : HttpError(404)
     *     class UnauthorizedError(reason: String) : HttpError(401)
     * }
     * ```
     * **sealed interface**
     * - the same functionality as sealed class (abstract), but its an interface (wow)
     * - if we do not need a constructor, prefer to use sealed interface, it saves memory for children
     * ```
     * sealed interface HttpErrorInterface {
     *     object ErrorNotFound : HttpErrorInterface
     *     class UnauthorizedError(reason: String) : HttpErrorInterface
     * }
     * ```
     */
    private fun enumsSealed() {}

    /**
     * **Functional, (SAM) interface**
     *
     * SAM - Single Abstract Method interface
     * - can have only 1 abstract member, several non-abstract members
     * - use fun modifier to create SAM interface
     * - instead of creating a class implementing interface, can use lambda expression
     * ```
     * fun interface KRunnable {
     *    fun invoke()
     * }
     * val runnable = KRunnable { doSomething() }
     * ```
     */
    private fun functionalInterface() {}

    /**
     * **Type aliases**
     *
     * provide alternative names for existing types, do not introduce new types
     * ```
     * typealias FileTable<K> = MutableMap<K, MutableList<File>>
     * typealias Predicate<T> = (T) -> Boolean
     * ```
     */
    private fun typeAliases() {}

    /**
     * **const** - compile-time constants, read-only
     * - top-level, a part of object or companion-object
     * - only primitives or String
     *
     * - const is inlined, and the reference will be replaced with actual value
     * - the field will not be removed, and can be accessed using **reflection**
     *
     * **var** - mutable
     *
     * **val** - immutable
     *
     * **custom setter** called every time you assign a value to the property, except its initialization
     *
     * **lateinit**
     * - only var
     * - inside class body, top-level property, local variable
     * - must be non-nullable
     * - must be not primitive type
     * - accessing before initialization throws exception
     */
    private fun properties() {
        class MutableRectangle(val width: Int, var height: Int) {
            var area: Int
                get() = width * height
                set(value) {
                    height = value / width
                }
            var isSquare: Boolean = width == height
                private set

            // backing field
            var counter = 0
                set(value) {
                    if (value > 0) {
                        field = value //field = counter
                    }
                }
        }
    }

    /**
     * **destructing declaration**
     *
     * destructing declaration creates multiple variables at once
     * ```
     * val (name, age) = person
     *
     * // compiled to:
     * val name = person.component1()
     * val age = person.component2()
     * ```
     * maps:
     * ```
     * for((key, value) in map) {...}
     * ```
     * to skip the componentI can use underscode:
     * componentN function is not called for skipped elements
     * ```
     * val (_, status) = getResult()
     * ```
     *
     */
    private fun destructingDeclaration() {}

}